# IntelliJ IDEA MCP 服务器 - 架构文档

## 文档信息

- **文档版本**: v1.0
- **创建日期**: 2025-11-13
- **文档状态**: 架构设计阶段
- **项目名称**: IDEA MCP Server

---

## 1. 架构概述

### 1.1 总体架构

本项目采用**三层架构**设计,将 IntelliJ IDEA 的功能通过 MCP 协议暴露给 AI 工具:

```
┌─────────────────────────────────────────────────────────────┐
│                        AI 工具层                              │
│                   (Claude Code / Cursor)                     │
└────────────────────┬────────────────────────────────────────┘
                     │ MCP Protocol (stdio)
                     ▼
┌─────────────────────────────────────────────────────────────┐
│                      MCP Server 层                            │
│              (Node.js 18+ / TypeScript)                      │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  - MCP 协议实现 (stdio transport)                    │   │
│  │  - HTTP Client (axios)                              │   │
│  │  - 请求转换和路由                                     │   │
│  │  - 响应处理和格式化                                   │   │
│  │  - 连接管理和重试                                     │   │
│  └──────────────────────────────────────────────────────┘   │
└────────────────────┬────────────────────────────────────────┘
                     │ HTTP REST API
                     │ (JSON)
                     ▼
┌─────────────────────────────────────────────────────────────┐
│                    IDEA Plugin 层                            │
│                   (Java 17+)                                 │
│                   (包名: com.ly.ideamcp)                     │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  HTTP Server 模块                                     │   │
│  │  - Embedded Undertow Server                         │   │
│  │  - RESTful API Endpoints                            │   │
│  │  - 认证和授权                                         │   │
│  │  - 请求验证                                           │   │
│  └──────────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  功能模块                                              │   │
│  │  - RefactoringService (重构)                         │   │
│  │  - NavigationService (导航)                          │   │
│  │  - AnalysisService (分析)                            │   │
│  │  - DebugService (调试)                               │   │
│  │  - GenerationService (代码生成)                      │   │
│  │  - SearchService (搜索)                              │   │
│  │  - ProjectService (项目管理)                         │   │
│  └──────────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  工具类                                                │   │
│  │  - ProjectManager (项目管理)                          │   │
│  │  - FileLocationResolver (文件定位)                    │   │
│  │  - ThreadHelper (线程管理)                            │   │
│  │  - ResponseSerializer (序列化)                        │   │
│  └──────────────────────────────────────────────────────┘   │
└────────────────────┬────────────────────────────────────────┘
                     │ IntelliJ Platform API
                     ▼
┌─────────────────────────────────────────────────────────────┐
│                    IntelliJ IDEA 核心                         │
│  - PSI (Program Structure Interface)                        │
│  - 索引系统                                                   │
│  - 重构引擎                                                   │
│  - 调试器                                                     │
│  - VCS 集成                                                  │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 设计原则

1. **职责分离**: 每层负责特定的功能,降低耦合
2. **单向依赖**: 上层依赖下层,下层不依赖上层
3. **接口抽象**: 通过接口定义层间通信
4. **可扩展性**: 模块化设计,易于添加新功能
5. **容错性**: 每层都有错误处理和降级策略

### 1.3 关键技术决策

| 决策点 | 选择 | 理由 |
|--------|------|------|
| 项目结构 | 单仓库多模块 (Monorepo) | 统一版本管理、便于开发 |
| 包名规范 | com.ly.ideamcp | 统一命名空间 |
| Plugin 开发语言 | Kotlin 1.9+ (JVM 17) | JetBrains 官方语言、简洁高效、空安全 |
| MCP Server 语言 | TypeScript/Node.js 18+ | 类型安全、MCP 生态标准 |
| Plugin HTTP Server | Undertow 2.3+ | 轻量(1MB)、高性能、易嵌入 |
| MCP 通信方式 | stdio | MCP 标准、简单可靠 |
| Plugin 通信协议 | HTTP REST API | 标准化、易调试 |
| 数据格式 | JSON | 标准化、可读性强 |
| 认证方式 | Bearer Token (可选) | 简单、安全、标准 |

---

## 2. 层次架构详解

### 2.1 AI 工具层

**职责**:
- 与用户交互,理解用户意图
- 通过 MCP 协议调用 IDEA 功能
- 展示操作结果

**支持的工具**:
- Claude Code
- Cursor
- 其他支持 MCP 的 AI 工具

**通信方式**:
- stdio (标准输入输出) - 本项目采用此方式

---

### 2.2 MCP Server 层

#### 2.2.1 职责

- **协议适配**: 实现 MCP 协议规范
- **请求转换**: 将 MCP 请求转换为 HTTP 请求
- **响应处理**: 将 HTTP 响应格式化为 MCP 响应
- **连接管理**: 管理与 IDEA Plugin 的连接
- **错误处理**: 统一处理错误和异常

#### 2.2.2 核心组件

```typescript
MCP Server
├── Server (MCP 服务器主逻辑)
│   ├── ToolRegistry (工具注册表)
│   ├── RequestHandler (请求处理器)
│   └── ResponseFormatter (响应格式化器)
├── IdeaClient (HTTP 客户端)
│   ├── ConnectionPool (连接池)
│   ├── RetryStrategy (重试策略)
│   └── RequestInterceptor (请求拦截器)
└── Tools (工具定义)
    ├── RefactoringTools
    ├── NavigationTools
    ├── AnalysisTools
    ├── DebugTools
    ├── GenerationTools
    ├── SearchTools
    └── ProjectTools
```

#### 2.2.3 工具注册机制

```typescript
// 工具接口
interface Tool {
  name: string;
  description: string;
  inputSchema: JSONSchema;
  execute: (args: any) => Promise<any>;
}

// 工具注册
class ToolRegistry {
  private tools: Map<string, Tool> = new Map();

  register(tool: Tool): void {
    this.tools.set(tool.name, tool);
  }

  get(name: string): Tool | undefined {
    return this.tools.get(name);
  }

  list(): Tool[] {
    return Array.from(this.tools.values());
  }
}
```

#### 2.2.4 请求流程

```
1. AI 工具发起 MCP 请求
   ↓
2. MCP Server 解析请求
   ↓
3. 查找对应的工具
   ↓
4. 转换为 HTTP 请求
   ↓
5. 发送到 IDEA Plugin
   ↓
6. 接收 HTTP 响应
   ↓
7. 格式化为 MCP 响应
   ↓
8. 返回给 AI 工具
```

---

### 2.3 IDEA Plugin 层

#### 2.3.1 职责

- **HTTP 服务**: 提供 RESTful API 端点
- **请求验证**: 验证请求参数和权限
- **功能实现**: 调用 IDEA API 实现具体功能
- **响应封装**: 统一响应格式
- **异常处理**: 捕获和处理异常

#### 2.3.2 模块架构

```
IDEA Plugin (com.ly.ideamcp)
├── Server 模块
│   ├── UndertowServer (Undertow HTTP 服务器)
│   ├── RequestHandler (请求处理器)
│   ├── RouterConfig (路由配置)
│   ├── AuthFilter (认证过滤器)
│   └── CorsFilter (CORS 过滤器)
├── Service 模块
│   ├── RefactoringService
│   │   ├── RenameHandler
│   │   ├── ExtractMethodHandler
│   │   ├── ExtractVariableHandler
│   │   └── InlineHandler
│   ├── NavigationService
│   │   ├── FindUsagesHandler
│   │   ├── GotoDefinitionHandler
│   │   └── FindImplementationsHandler
│   ├── AnalysisService
│   │   ├── InspectionRunner
│   │   ├── ErrorCollector
│   │   └── DependencyAnalyzer
│   ├── DebugService
│   │   ├── BreakpointManager
│   │   ├── DebugSessionManager
│   │   └── ExpressionEvaluator
│   ├── GenerationService
│   ├── SearchService
│   └── ProjectService
├── Utils 模块
│   ├── PsiHelper (PSI 工具)
│   ├── ThreadHelper (线程管理)
│   ├── OffsetHelper (偏移量转换)
│   └── ResponseSerializer (序列化)
├── Models 模块
│   ├── Request Models
│   ├── Response Models
│   └── Error Models
└── Config 模块
    ├── PluginSettings
    └── SecurityConfig
```

#### 2.3.3 服务接口设计

```kotlin
// 服务基础接口
interface IdeaService {
    /** 服务名称 */
    val serviceName: String

    /** 检查服务是否可用 */
    fun isAvailable(): Boolean
}

// 重构服务接口
interface RefactoringService : IdeaService {
    fun rename(request: RenameRequest): RenameResponse
    fun extractMethod(request: ExtractMethodRequest): ExtractMethodResponse
    fun extractVariable(request: ExtractVariableRequest): ExtractVariableResponse
    fun inline(request: InlineRequest): InlineResponse
    fun safeDelete(request: SafeDeleteRequest): SafeDeleteResponse
}

// 导航服务接口
interface NavigationService : IdeaService {
    fun findUsages(request: FindUsagesRequest): FindUsagesResponse
    fun gotoDefinition(request: GotoDefinitionRequest): GotoDefinitionResponse
    fun findImplementations(request: FindImplementationsRequest): FindImplementationsResponse
}
```

#### 2.3.4 线程模型

IDEA 插件必须遵守严格的线程模型:

```kotlin
// 读操作 (Read Action)
fun <T> executeReadAction(action: () -> T): T {
    return ApplicationManager.getApplication()
        .runReadAction(Computable { action() })
}

// 写操作 (Write Action)
fun executeWriteAction(action: () -> Unit) {
    ApplicationManager.getApplication()
        .runWriteAction { action() }
}

// 后台任务
fun <T> executeInBackground(
    title: String,
    action: () -> T
): CompletableFuture<T> {
    val future = CompletableFuture<T>()

    ProgressManager.getInstance().run(
        object : Task.Backgroundable(project, title, true) {
            override fun run(indicator: ProgressIndicator) {
                try {
                    val result = action()
                    future.complete(result)
                } catch (e: Exception) {
                    future.completeExceptionally(e)
                }
            }
        }
    )

    return future
}
```

---

## 3. 通信协议设计

### 3.1 MCP 协议层

#### 3.1.1 协议规范

- **版本**: MCP 1.0
- **传输**: stdio (标准输入输出)
- **格式**: JSON-RPC 2.0

#### 3.1.2 工具定义

```typescript
{
  "name": "refactor_rename",
  "description": "重命名代码中的符号",
  "inputSchema": {
    "type": "object",
    "properties": {
      "filePath": {
        "type": "string",
        "description": "文件路径"
      },
      "offset": {
        "type": "number",
        "description": "符号位置"
      },
      "newName": {
        "type": "string",
        "description": "新名称"
      }
    },
    "required": ["filePath", "offset", "newName"]
  }
}
```

#### 3.1.3 请求格式

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "refactor_rename",
    "arguments": {
      "filePath": "/src/User.java",
      "offset": 1234,
      "newName": "Customer"
    }
  }
}
```

#### 3.1.4 响应格式

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "{\"success\": true, \"data\": {...}}"
      }
    ]
  }
}
```

---

### 3.2 HTTP API 层

#### 3.2.1 API 规范

- **协议**: HTTP/1.1
- **端口**: 58888 (可配置)
- **Base URL**: `http://localhost:58888/api/v1`
- **数据格式**: JSON
- **认证**: Bearer Token (可选)

#### 3.2.2 通用请求头

```http
Content-Type: application/json
Authorization: Bearer <token>
X-Request-ID: <uuid>
```

#### 3.2.3 通用响应格式

**成功响应**:
```json
{
  "success": true,
  "data": { ... },
  "requestId": "uuid",
  "timestamp": 1234567890
}
```

**错误响应**:
```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "错误描述",
    "details": { ... }
  },
  "requestId": "uuid",
  "timestamp": 1234567890
}
```

#### 3.2.4 错误码设计

```java
public enum ErrorCode {
    // 4xx 客户端错误
    INVALID_PARAMETERS(400, "参数无效"),
    UNAUTHORIZED(401, "未授权"),
    FILE_NOT_FOUND(404, "文件未找到"),
    ELEMENT_NOT_FOUND(404, "元素未找到"),

    // 5xx 服务端错误
    INTERNAL_ERROR(500, "内部错误"),
    PROJECT_NOT_FOUND(500, "项目未找到"),
    INDEX_NOT_READY(503, "索引未就绪"),
    REFACTORING_FAILED(500, "重构失败"),
    OPERATION_CANCELLED(500, "操作被取消");

    private final int httpStatus;
    private final String message;
}
```

---

## 4. 数据模型设计

### 4.1 请求模型

```kotlin
// 基础请求
abstract class BaseRequest(
    val requestId: String = UUID.randomUUID().toString(),
    val timestamp: Long = System.currentTimeMillis()
)

// 重命名请求
data class RenameRequest(
    val filePath: String,
    val offset: Int,
    val newName: String,
    val searchInComments: Boolean = false,
    val searchInStrings: Boolean = false,
    val preview: Boolean = false
) : BaseRequest()

// 查找用途请求
data class FindUsagesRequest(
    val filePath: String,
    val offset: Int,
    val scope: SearchScope = SearchScope.PROJECT,
    val includeTests: Boolean = true
) : BaseRequest()
```

### 4.2 响应模型

```kotlin
// 基础响应
abstract class BaseResponse(
    val success: Boolean,
    val requestId: String,
    val timestamp: Long = System.currentTimeMillis()
)

// 成功响应
data class SuccessResponse<T>(
    val data: T,
    val reqId: String
) : BaseResponse(success = true, requestId = reqId)

// 错误响应
data class ErrorResponse(
    val error: ErrorInfo,
    val reqId: String
) : BaseResponse(success = false, requestId = reqId)

// 错误信息
data class ErrorInfo(
    val code: String,
    val message: String,
    val details: Map<String, Any>? = null
)
```

### 4.3 领域模型

```kotlin
// 代码位置
data class CodeLocation(
    val filePath: String,
    val line: Int,
    val column: Int,
    val offset: Int
)

// 代码用途
data class CodeUsage(
    val location: CodeLocation,
    val type: UsageType,
    val context: String,
    val snippet: String
)

// 代码变更
data class CodeChange(
    val filePath: String,
    val modifications: List<Modification>
)

// 修改项
data class Modification(
    val startOffset: Int,
    val endOffset: Int,
    val oldText: String,
    val newText: String
)
```

---

## 5. 核心流程设计

### 5.1 重构流程

```
┌─────────────────────────────────────────────────────────┐
│                    重构流程                              │
└─────────────────────────────────────────────────────────┘

1. 接收重构请求
   ↓
2. 验证参数
   ↓
3. 查找 PSI 元素
   ↓
4. 创建重构处理器
   ↓
5. 检查前置条件
   ├─ 失败 → 返回错误
   └─ 成功 ↓
6. 查找所有使用
   ↓
7. 检查冲突
   ├─ 有冲突 → 返回冲突信息
   └─ 无冲突 ↓
8. 预览模式?
   ├─ 是 → 返回预览结果
   └─ 否 ↓
9. 执行重构 (WriteAction)
   ↓
10. 提交变更
    ↓
11. 返回成功结果
```

### 5.2 调试流程

```
┌─────────────────────────────────────────────────────────┐
│                    调试流程                              │
└─────────────────────────────────────────────────────────┘

1. 设置断点
   ↓
2. 启动调试会话
   ├─ 创建运行配置
   ├─ 启动调试器
   └─ 等待断点触发
   ↓
3. 断点触发
   ├─ 挂起线程
   └─ 通知 MCP Server
   ↓
4. 调试操作
   ├─ 查看变量
   ├─ 计算表达式
   ├─ 修改变量
   └─ 单步执行
   ↓
5. 继续执行
   ↓
6. 会话结束
   └─ 清理资源
```

### 5.3 错误处理流程

```
┌─────────────────────────────────────────────────────────┐
│                  错误处理流程                            │
└─────────────────────────────────────────────────────────┘

1. 捕获异常
   ↓
2. 确定错误类型
   ├─ 参数错误 → 400
   ├─ 未授权 → 401
   ├─ 资源未找到 → 404
   ├─ 索引未就绪 → 503
   └─ 其他 → 500
   ↓
3. 记录日志
   ├─ ERROR 级别: 系统错误
   ├─ WARN 级别: 业务错误
   └─ INFO 级别: 正常流程
   ↓
4. 构建错误响应
   ├─ 错误码
   ├─ 错误消息
   └─ 详细信息
   ↓
5. 返回错误响应
```

---

## 6. 安全架构

### 6.1 认证机制

```java
public class AuthenticationFilter implements HttpHandler {
    private final SecurityConfig config;

    @Override
    public void handleRequest(HttpServerExchange exchange) {
        // 跳过认证?
        if (!config.isAuthEnabled()) {
            next.handleRequest(exchange);
            return;
        }

        // 获取 Token
        String authHeader = exchange.getRequestHeaders()
            .getFirst("Authorization");

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            sendUnauthorized(exchange);
            return;
        }

        String token = authHeader.substring(7);

        // 验证 Token
        if (!config.getToken().equals(token)) {
            sendUnauthorized(exchange);
            return;
        }

        // 验证通过
        next.handleRequest(exchange);
    }
}
```

### 6.2 授权机制

```java
public class AuthorizationFilter implements HttpHandler {
    private static final Set<String> READ_ONLY_ENDPOINTS = Set.of(
        "/navigation/",
        "/analysis/",
        "/search/",
        "/project/info"
    );

    @Override
    public void handleRequest(HttpServerExchange exchange) {
        String path = exchange.getRequestPath();
        String method = exchange.getRequestMethod().toString();

        // 写操作需要额外权限
        if (isWriteOperation(path) && !hasWritePermission()) {
            sendForbidden(exchange);
            return;
        }

        next.handleRequest(exchange);
    }

    private boolean isWriteOperation(String path) {
        return !READ_ONLY_ENDPOINTS.stream()
            .anyMatch(path::startsWith);
    }
}
```

### 6.3 限流机制

```java
public class RateLimiter {
    private final Map<String, TokenBucket> buckets = new ConcurrentHashMap<>();
    private final int maxRequestsPerMinute;

    public boolean allowRequest(String clientId) {
        TokenBucket bucket = buckets.computeIfAbsent(
            clientId,
            k -> new TokenBucket(maxRequestsPerMinute)
        );

        return bucket.tryConsume();
    }

    private static class TokenBucket {
        private final int capacity;
        private int tokens;
        private long lastRefillTime;

        public synchronized boolean tryConsume() {
            refill();
            if (tokens > 0) {
                tokens--;
                return true;
            }
            return false;
        }

        private void refill() {
            long now = System.currentTimeMillis();
            long elapsed = now - lastRefillTime;
            int newTokens = (int) (elapsed / 60000 * capacity);
            if (newTokens > 0) {
                tokens = Math.min(capacity, tokens + newTokens);
                lastRefillTime = now;
            }
        }
    }
}
```

### 6.4 审计日志

```java
public class AuditLogger {
    private static final Logger LOG = Logger.getInstance(AuditLogger.class);

    public void logOperation(
        String operation,
        String user,
        String resource,
        boolean success,
        String details
    ) {
        AuditLog log = AuditLog.builder()
            .timestamp(System.currentTimeMillis())
            .operation(operation)
            .user(user)
            .resource(resource)
            .success(success)
            .details(details)
            .build();

        LOG.info("AUDIT: " + log.toString());

        // 可选: 保存到数据库
        // auditRepository.save(log);
    }
}
```

---

## 7. 性能优化设计

### 7.1 缓存策略

```java
public class CacheManager {
    // 项目结构缓存 (30分钟)
    private final LoadingCache<String, ProjectStructure> projectCache =
        CacheBuilder.newBuilder()
            .expireAfterWrite(30, TimeUnit.MINUTES)
            .maximumSize(100)
            .build(new CacheLoader<String, ProjectStructure>() {
                @Override
                public ProjectStructure load(String projectPath) {
                    return loadProjectStructure(projectPath);
                }
            });

    // 符号索引缓存 (10分钟)
    private final LoadingCache<SymbolKey, PsiElement> symbolCache =
        CacheBuilder.newBuilder()
            .expireAfterWrite(10, TimeUnit.MINUTES)
            .maximumSize(1000)
            .build(new CacheLoader<SymbolKey, PsiElement>() {
                @Override
                public PsiElement load(SymbolKey key) {
                    return findElement(key);
                }
            });

    // 文件监听器: 文件变更时清除缓存
    public void onFileChanged(VirtualFile file) {
        symbolCache.invalidateAll();
    }
}
```

### 7.2 异步处理

```java
public class AsyncExecutor {
    private final ExecutorService executor =
        Executors.newFixedThreadPool(10);

    public <T> CompletableFuture<T> executeAsync(
        String taskName,
        Callable<T> task
    ) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                LOG.info("Starting task: " + taskName);
                return task.call();
            } catch (Exception e) {
                throw new RuntimeException(e);
            } finally {
                LOG.info("Finished task: " + taskName);
            }
        }, executor);
    }

    public void shutdown() {
        executor.shutdown();
    }
}
```

### 7.3 批量操作优化

```java
public class BatchProcessor {
    public <T, R> List<R> processBatch(
        List<T> items,
        Function<T, R> processor,
        int batchSize
    ) {
        List<R> results = new ArrayList<>();

        // 分批处理
        for (int i = 0; i < items.size(); i += batchSize) {
            List<T> batch = items.subList(
                i,
                Math.min(i + batchSize, items.size())
            );

            // 批量处理
            List<R> batchResults = batch.parallelStream()
                .map(processor)
                .collect(Collectors.toList());

            results.addAll(batchResults);
        }

        return results;
    }
}
```

---

## 8. 监控和运维

### 8.1 健康检查

```java
@RestController
public class HealthController {
    @GetMapping("/health")
    public HealthResponse health() {
        return HealthResponse.builder()
            .status("ok")
            .version(PluginVersion.VERSION)
            .ideaVersion(ApplicationInfo.getInstance().getFullVersion())
            .indexReady(isIndexReady())
            .projectOpen(hasOpenProject())
            .build();
    }

    private boolean isIndexReady() {
        return !DumbService.getInstance(project).isDumb();
    }
}
```

### 8.2 指标收集

```java
public class MetricsCollector {
    private final AtomicLong requestCount = new AtomicLong();
    private final AtomicLong errorCount = new AtomicLong();
    private final ConcurrentMap<String, AtomicLong> operationCounts =
        new ConcurrentHashMap<>();
    private final ConcurrentMap<String, AtomicLong> operationDurations =
        new ConcurrentHashMap<>();

    public void recordRequest(String operation, long duration, boolean success) {
        requestCount.incrementAndGet();
        if (!success) {
            errorCount.incrementAndGet();
        }

        operationCounts.computeIfAbsent(operation, k -> new AtomicLong())
            .incrementAndGet();
        operationDurations.computeIfAbsent(operation, k -> new AtomicLong())
            .addAndGet(duration);
    }

    @GetMapping("/metrics")
    public MetricsResponse getMetrics() {
        return MetricsResponse.builder()
            .totalRequests(requestCount.get())
            .totalErrors(errorCount.get())
            .operationMetrics(buildOperationMetrics())
            .build();
    }
}
```

### 8.3 日志设计

```java
public class LoggingConfig {
    // 使用 IDEA 的日志系统
    private static final Logger LOG = Logger.getInstance(IdeaMcpPlugin.class);

    // 分级日志
    public void logInfo(String message) {
        LOG.info("[IDEA-MCP] " + message);
    }

    public void logWarn(String message) {
        LOG.warn("[IDEA-MCP] " + message);
    }

    public void logError(String message, Throwable error) {
        LOG.error("[IDEA-MCP] " + message, error);
    }

    // 性能日志
    public void logPerformance(String operation, long duration) {
        if (duration > 1000) {
            LOG.warn("[PERF] Slow operation: " + operation + " took " + duration + "ms");
        } else {
            LOG.debug("[PERF] " + operation + " took " + duration + "ms");
        }
    }
}
```

---

## 9. 部署架构

### 9.1 本地部署

```
┌─────────────────────────────────────────────┐
│            开发者机器                        │
│                                             │
│  ┌───────────────────────────────────────┐ │
│  │  IntelliJ IDEA                        │ │
│  │  ├─ IDEA MCP Plugin                   │ │
│  │  │  └─ HTTP Server :58888             │ │
│  │  └─ 打开的项目                         │ │
│  └───────────────────────────────────────┘ │
│           ↑ HTTP                            │
│           │                                 │
│  ┌───────────────────────────────────────┐ │
│  │  MCP Server (Node.js)                 │ │
│  │  ├─ stdin/stdout                      │ │
│  │  └─ HTTP Client                       │ │
│  └───────────────────────────────────────┘ │
│           ↑ stdio                           │
│           │                                 │
│  ┌───────────────────────────────────────┐ │
│  │  AI Tool (Claude Code)                │ │
│  │  └─ MCP Client                        │ │
│  └───────────────────────────────────────┘ │
└─────────────────────────────────────────────┘
```

### 9.2 团队部署

```
┌─────────────────────────────────────────────┐
│          共享服务器                          │
│                                             │
│  ┌───────────────────────────────────────┐ │
│  │  Headless IDEA Instance               │ │
│  │  ├─ IDEA MCP Plugin                   │ │
│  │  │  └─ HTTP Server :58888             │ │
│  │  └─ 项目代码                           │ │
│  └───────────────────────────────────────┘ │
└─────────────────┬───────────────────────────┘
                  │ HTTP (LAN)
         ┌────────┴────────┐
         │                 │
┌────────▼───────┐  ┌──────▼─────────┐
│ 开发者 A        │  │ 开发者 B        │
│ ├─ MCP Server  │  │ ├─ MCP Server  │
│ └─ AI Tool     │  │ └─ AI Tool     │
└────────────────┘  └────────────────┘
```

---

## 10. 技术栈总结

### 10.1 项目结构

- **项目类型**: 单仓库多模块 (Monorepo)
- **包名**: com.ly.ideamcp
- **构建工具**: Gradle 8.0+

### 10.2 IDEA Plugin 模块

| 技术 | 版本 | 用途 |
|------|------|------|
| Java | 17+ | 开发语言 |
| IntelliJ Platform SDK | 2024.1+ | 插件框架 |
| Undertow | 2.3+ | HTTP 服务器 |
| Gson | 2.10+ | JSON 序列化 |
| Gradle | 8.0+ | 构建工具 |

### 10.3 MCP Server 模块

| 技术 | 版本 | 用途 |
|------|------|------|
| Node.js | 18+ | 运行时 |
| TypeScript | 5.3+ | 开发语言 |
| @modelcontextprotocol/sdk | 0.5+ | MCP 协议 (stdio) |
| Axios | 1.6+ | HTTP 客户端 |

---

## 11. 项目结构

### 11.1 Monorepo 结构

```
idea-mcp/
├── idea-plugin/              # IDEA Plugin 模块
│   ├── src/
│   │   └── main/
│   │       └── java/
│   │           └── com/ly/ideamcp/
│   │               ├── server/      # HTTP 服务器
│   │               ├── service/     # 业务服务
│   │               ├── util/        # 工具类
│   │               └── model/       # 数据模型
│   ├── build.gradle.kts
│   └── plugin.xml
├── mcp-server/               # MCP Server 模块
│   ├── src/
│   │   ├── index.ts         # 入口
│   │   ├── server.ts        # MCP Server
│   │   ├── ideaClient.ts    # HTTP 客户端
│   │   └── tools/           # 工具定义
│   ├── package.json
│   └── tsconfig.json
├── docs/                     # 文档
├── build.gradle.kts          # 根构建脚本
├── settings.gradle.kts       # 项目设置
└── README.md
```

### 11.2 开发流程

1. **阶段一 (MVP)**: 完成基础架构和核心功能
2. **阶段二**: 完善重构和调试功能
3. **阶段三**: 优化性能和完善文档
4. **阶段四**: 发布和推广

---

**文档维护**: 架构变更时需要及时更新此文档。
